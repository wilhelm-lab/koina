import numpy as np

# from spectrum_fundamentals.annotation.annotation import peak_pos_xl_cms2

VEC_LENGTH = 348


def peak_pos_xl_cms2(unmod_seq: str, crosslinker_position: int) -> list:
    """
    Determines the positions of all potential normal and xl fragments within the vector generated by generate_annotation_matrix.

    This fuction is used only for cleavable crosslinked peptides.

    :param unmod_seq: Un modified peptide sequence
    :param crosslinker_position: The position of crosslinker
    :raises ValueError: if Peptides exceeding a length of 30.
    :return: position of diffrent fragments as list
    """
    peaks_y = []
    peaks_b = []
    peaks_yshort = []
    peaks_bshort = []
    peaks_ylong = []
    peaks_blong = []

    if len(unmod_seq) < 31:
        if crosslinker_position != 1:
            peaks_b = np.array([3, 4, 5])
            peaks_b = np.tile(peaks_b, crosslinker_position - 1) + np.repeat(
                np.arange(crosslinker_position - 1) * 6, 3
            )
            first_pos_ylong = (
                (len(unmod_seq) - crosslinker_position) * 6
            ) + 174  # fisrt  position for ylong
            peaks_ylong = np.arange(first_pos_ylong, first_pos_ylong + 3)
            peaks_ylong = np.tile(peaks_ylong, crosslinker_position - 1) + np.repeat(
                np.arange(crosslinker_position - 1) * 6, 3
            )

        if len(unmod_seq) != crosslinker_position:
            peaks_y = [0, 1, 2]
            peaks_y = np.tile(
                peaks_y, len(unmod_seq) - crosslinker_position
            ) + np.repeat(np.arange(len(unmod_seq) - crosslinker_position) * 6, 3)
            first_pos_blong = (
                ((crosslinker_position - 1) * 6) + 174 + 3
            )  # fisrt  position for blong
            peaks_blong = [first_pos_blong, first_pos_blong + 1, first_pos_blong + 2]
            peaks_blong = np.arange(first_pos_blong, first_pos_blong + 3)
            peaks_blong = list(
                np.tile(peaks_blong, len(unmod_seq) - crosslinker_position)
                + np.repeat(np.arange(len(unmod_seq) - crosslinker_position) * 6, 3)
            )

        peaks_yshort = [x - 174 for x in peaks_ylong]
        peaks_bshort = [x - 174 for x in peaks_blong]
        peaks_range = (
            list(peaks_y)
            + list(peaks_b)
            + list(peaks_yshort)
            + list(peaks_bshort)
            + list(peaks_ylong)
            + list(peaks_blong)
        )
        peaks_range.sort()
    else:
        raise ValueError(
            f"Peptides exceeding a length of 30 are not supported: {len(unmod_seq)}"
        )

    return (
        peaks_range,
        peaks_y,
        peaks_b,
        peaks_yshort,
        peaks_bshort,
        peaks_ylong,
        peaks_blong,
    )


def create_masking(unmod_seq, crosslinker_position):
    """
    assume reshaped output of xl-prosit, shape sould be (num_seq, 174 * 2)
    set filtered output where not allowed positions are set to -1
    we set charge = 2 for all peptide a and b
    """

    assert len(unmod_seq) == len(crosslinker_position)
    mask = np.ones(shape=(len(unmod_seq), VEC_LENGTH))
    for i in range(len(unmod_seq)):
        m = mask[i].copy()
        peaks_ranges = peak_pos_xl_cms2(unmod_seq[i], crosslinker_position[i])
        updated_mask = np.setdiff1d(np.arange(0, 348), peaks_ranges[0])
        updated_mask_charge_3 = np.arange(2, 348, 3)
        updated_mask = np.sort(np.concatenate((updated_mask, updated_mask_charge_3)))
        m[updated_mask] = np.nan
        mask[i] = m
    return mask


def apply_masking(peaks, mask):
    peaks[peaks < 0] = np.finfo(np.float32).eps
    out = np.multiply(peaks, mask)
    out = (out.T / np.nanmax(out, axis=1)).T
    return out

# Documentation generation via jinja
swagger_tmpl.yaml file contains the templatized version of swagger.yaml. The parameters that need to be filled out in that template file are both from notes.yaml in the models directory and the back-end of the triton server.
The script that fills out the template is called `swagger_gen.py`


These are the parameters below given to the jinja template.
```python
 context = {'models': models,'triton_server_ip':reverse_host,'triton_server_port':reverse_port}
```
`models` is a dictionary object contains everything from `v2/models/{model}/config` endpoint and `notes.yaml`

One can access the specific model's notes via: ` models[i]['note'] `
One also can access the specific model's input/output tensor via: ` models[i]['input'] ` and `models[i]['output']`



# Logic of swagger_gen.py

`Swagger.yaml` generation is a service that runs before serving of the Swagger. This service waits until the Triton and Reverse proxy servers are up and running.

When they're up, it sends request to the revers-eproxy to identify the input/output tensors of the models that are whitelisted in `model_names.json` file. Once the script identifies those data, it proceeds to look into `notes.yaml` file stored under the path points in `model_names.json`.

The `notes.yaml` contains some information we could not store anywhere else such as description, summary, tag and example of the models.

# Python GRPC example Code Generation

## Header boilerplate
`generate_grpc_header_boilierplate`
function generates the grpc initalization, server IP, and port.
## Input boilerplate

In input initalization you need to define the input tensors, input type, and input size. These information come from the notes.yaml example section
`generate_input_create_boilerplate`
function generates the input list, input type, and data for all of the input tensors

## Ouptut boilerplate
`generate_append_output_boilerplate`
The output boilerplate where it generates a code where it appends the output tensor layers into a list and prepares it for sending the
## Result boilerplate
`generate_output_boilerplate`

To get the result you have to send the input/output layer and store that information in result variable. This part of the code can be generated by the function. Additionally, it prints out the output tensors.
